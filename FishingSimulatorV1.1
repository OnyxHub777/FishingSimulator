local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/xHeptc/Kavo-UI-Library/main/source.lua"))()
local Window = Library.CreateLib("FishingSimulatorRevised-V1.1", "Midnight")
    -- MAIN
    local Main = Window:NewTab("Freeze")
    local MainSection = Main:NewSection("Main")


MainSection:NewButton("No Shark Damage", "Anti-SharkDamage", function()

local parentName = "GreatWhiteShark"
local partName = "Hitbox"
local chosenModel = nil

-- Function to recursively delete parts
local function deleteParts(parent)
    for _, child in ipairs(parent:GetDescendants()) do
        if child:IsA("BasePart") and child.Name == partName then
            child:Destroy()
        end
    end
end

-- Function to find all parents with the specified name
local function findParents(workspace, name)
    local parents = {}
    for _, child in ipairs(workspace:GetChildren()) do
        if child:IsA("Model") and child.Name == name then
            table.insert(parents, child)
        end
        findParents(child, name)
    end
    return parents
end

-- Function to handle model deletion
local function handleDeletion()
    if chosenModel then
        chosenModel = nil
        print("Chosen model deleted. Waiting for respawn...")
    end
end

-- Find parents with the specified name
local parents = findParents(game.Workspace, parentName)

-- Delete parts within the parents
if #parents > 0 then
    for _, parent in ipairs(parents) do
        deleteParts(parent)
    end
    print("Deleted all parts named '" .. partName .. "' within parents named '" .. parentName .. "'.")
else
    warn("No parents named '" .. parentName .. "' found.")
end

-- Set the chosenModel variable to the newly spawned model
chosenModel = game.Workspace:FindFirstChild(parentName)

-- Listen for model deletion
if chosenModel then
    chosenModel.AncestryChanged:Connect(handleDeletion)
end

end)




MainSection:NewButton("No Orca Damage", "Anti-OrcaDamage", function()

local parentName = "KillerWhale"
local partName = "Hitbox"
local chosenModel = nil

-- Function to recursively delete parts
local function deleteParts(parent)
    for _, child in ipairs(parent:GetDescendants()) do
        if child:IsA("BasePart") and child.Name == partName then
            child:Destroy()
        end
    end
end

-- Function to find all parents with the specified name
local function findParents(workspace, name)
    local parents = {}
    for _, child in ipairs(workspace:GetChildren()) do
        if child:IsA("Model") and child.Name == name then
            table.insert(parents, child)
        end
        findParents(child, name)
    end
    return parents
end

-- Function to handle model deletion
local function handleDeletion()
    if chosenModel then
        chosenModel = nil
        print("Chosen model deleted. Waiting for respawn...")
    end
end

-- Find parents with the specified name
local parents = findParents(game.Workspace, parentName)

-- Delete parts within the parents
if #parents > 0 then
    for _, parent in ipairs(parents) do
        deleteParts(parent)
    end
    print("Deleted all parts named '" .. partName .. "' within parents named '" .. parentName .. "'.")
else
    warn("No parents named '" .. parentName .. "' found.")
end

-- Set the chosenModel variable to the newly spawned model
chosenModel = game.Workspace:FindFirstChild(parentName)

-- Listen for model deletion
if chosenModel then
    chosenModel.AncestryChanged:Connect(handleDeletion)
end

end)
